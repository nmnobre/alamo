#ifndef INTEGRATOR_TENSIONTESTSGCP_H
#define INTEGRATOR_TENSIONTESTSGCP_H
#include <iostream>
#include <fstream>
#include <iomanip>
#include <numeric>

#include "AMReX.H"
#include "AMReX_ParallelDescriptor.H"
#include "AMReX_ParmParse.H"

#include "Integrator/Integrator.H"

#include "IC/IC.H"
#include "IC/Ellipsoid.H"
#include "BC/BC.H"
#include "BC/Operator/Elastic/Constant.H"
#include "BC/Operator/Elastic/TensionTest.H"
#include "BC/Operator/Elastic/Expression.H"

#include "IC/Ellipse.H"
#include "Numeric/Stencil.H"

#include "Model/Solid/Solid.H"
#include "Solver/Nonlocal/Linear.H"
#include "Solver/Nonlocal/Newton.H"
#include "Model/Solid/Affine/CrystalPlastic.H"
#include "Model/Solid/Affine/StrainGradientCrystalPlastic.H"

#include "Model/Interface/Crack/Crack.H"
#include "Model/Interface/Crack/Constant.H"

#include "Operator/Operator.H"

#include "IO/ParmParse.H"

namespace Integrator
{
template<class MODEL>
class TensionTestSGCP : public Integrator
{
    //using model_type = Model::Solid::Affine::Isotropic;
public:
    /// \brief Read in parameters and register field variables
    TensionTestSGCP()
    {
        
        RegisterNodalFab(disp_mf, AMREX_SPACEDIM, 2, "disp",true);
        RegisterNodalFab(rhs_mf, AMREX_SPACEDIM, 2, "rhs",true);
        RegisterNodalFab(stress_mf, AMREX_SPACEDIM * AMREX_SPACEDIM, 2, "stress",true);
        RegisterNodalFab(strain_mf, AMREX_SPACEDIM * AMREX_SPACEDIM, 2, "strain",true);

        {
            IO::ParmParse pp_crack("crack");
            pp_crack.query("modulus_scaling_max",crack.scaleModulusMax);
            pp_crack.query("refinement_threshold",crack.refinement_threshold);

            pp_crack.queryclass("constant",crack.cracktype);

            IO::ParmParse pp("crack.ic");
            pp.queryarr("type", crack.ic_type);
            
            if (crack.ic_type.size() == 0) crack.is_ic = false;
            else
            {
                crack.is_ic = true;
                for (int i = 0; i < crack.ic_type.size(); i++)
                {
                    if (crack.ic_type[i] == "ellipsoid")
                    {
                        IC::Ellipsoid *tmpic = new IC::Ellipsoid(geom);
                        pp.queryclass("ellipsoid",*tmpic);
                        crack.ic.push_back(tmpic);
                    }
                    else
                        Util::Abort(INFO, "This IC is not functional for this case yet");
                }
            }
            RegisterNodalFab(crack.c_mf, 1, 2, "crack", true);
        }
        

        {
            IO::ParmParse pp("elastic");
            int nmodels = 1;
            pp.query("nmodels",nmodels);
            for (int i = 0; i<nmodels; i++)
            {
                std::string name = "model" + std::to_string(i+1);
                MODEL tmp_model;
                pp.queryclass(name.data(), tmp_model);
                elastic.models.push_back(tmp_model);
            }
            Util::Assert(INFO,TEST(elastic.models.size() > 0));
            RegisterNodalFab(eta_mf, elastic.models.size(), 2, "eta",true);    

            std::string bc_type = "constant";
            pp.query("bc.type",bc_type);
            if (bc_type == "constant")
            {
                elastic.bc = new BC::Operator::Elastic::Constant();
                pp.queryclass("bc",static_cast<BC::Operator::Elastic::Constant*>(elastic.bc));
            }
            else if (bc_type == "tension_test")
            {
                elastic.bc = new BC::Operator::Elastic::TensionTest();
                pp.queryclass("bc.tension_test",static_cast<BC::Operator::Elastic::TensionTest*>(elastic.bc));
                Util::Message(INFO, "read this value");
            }
            else if (bc_type == "expression")
            {
                elastic.bc = new BC::Operator::Elastic::Expression();
                pp.queryclass("bc.expression",static_cast<BC::Operator::Elastic::Expression*>(elastic.bc));
            }
            pp.query("solver.int",elastic.interval);
            pp.query("ref_threshold",m_elastic_ref_threshold);
        }
        RegisterGeneralFab(model_mf, 1, 2);

        {
            IO::ParmParse pp("ic");
            std::string type;
            pp.query("type",type);
            if (type=="ellipse")
            {
                ic = new IC::Ellipse(geom);
                pp.queryclass("ellipse",static_cast<IC::Ellipse*>(ic));
            }
        }
        #if AMREX_SPACEDIM==3
        RegisterIntegratedVariable(&(trac_lo[0].data()[0]),"trac_lo_xx");
        #endif

        {
            IO::ParmParse pp("plastic");
            pp.query("on", plastic.on);
            if (plastic.on)
            {
                pp.query("hardening",plastic.hardening);
                pp.query("debug",plastic.debug);
                pp.query("epsp_evol_int",plastic.epsp_evol_int);
                // Hardcoded FCC in here..
                RegisterNodalFab(plastic.gamalpha_mf, 12, 2, "gamalpha", true);
                RegisterNodalFab(plastic.gamdotalpha_mf, 12, 2, "gamdotalpha", true);
                RegisterNodalFab(plastic.strainp_mf, AMREX_SPACEDIM * AMREX_SPACEDIM, 2, "strainp",true);
                RegisterNodalFab(plastic.strainp_eq_mf, 1, 2, "strainp_eq",true);
            }
        }
    }

protected:
    /// \brief Use the #ic object to initialize#Temp
    void Initialize(int lev) override
    {
        eta_mf[lev]->setVal(0.0);
        if (elastic.models.size() > 1 && ic)
            ic->Initialize(lev, eta_mf);
        else 
            eta_mf[lev]->setVal(1.0);
        
        disp_mf[lev]->setVal(0.);
        rhs_mf[lev]->setVal(0.);
        stress_mf[lev]->setVal(0.);
        strain_mf[lev]->setVal(0.);

        if(crack.is_ic)
        {
            crack.c_mf[lev]->setVal(1.0);
            for (int i = 0; i < crack.ic.size(); i++)
                crack.ic[i]->Add(lev,crack.c_mf);
        }
        else
            crack.c_mf[lev]->setVal(1.0);
        
        if (plastic.on)
        {
            plastic.strainp_mf[lev]->setVal(0.);
            plastic.strainp_eq_mf[lev]->setVal(0.0);
            plastic.gamalpha_mf[lev]->setVal(0.0);
            plastic.gamdotalpha_mf[lev]->setVal(0.0);
        }
        
        eta_mf[lev]->FillBoundary();
        for (MFIter mfi(*model_mf[lev], false); mfi.isValid(); ++mfi)
        {
            amrex::Box bx = mfi.grownnodaltilebox();
            amrex::Array4<MODEL> const &model = model_mf[lev]->array(mfi);
            amrex::Array4<const Set::Scalar> const &eta = eta_mf[lev]->array(mfi);
            amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) {
                model(i,j,k) = MODEL::Zero();
                if(plastic.on) model(i,j,k).SetHardening(plastic.hardening);
                for (unsigned int n = 0; n < elastic.models.size(); n++) 
                    model(i,j,k) += eta(i,j,k,n) * elastic.models[n];
            });
        }
        Util::RealFillBoundary(*model_mf[lev],geom[lev]);
    }

    void TimeStepBegin(Set::Scalar a_time, int a_iter) override
    {
        if (a_iter%plastic.epsp_evol_int == 0) plastic.do_epsp_evol = true;

        if(a_iter%elastic.interval) return;
        
        // Set linear elastic model
       
        for (int lev = 0; lev <= finest_level; ++lev)
        {
//            rhs_mf[lev]->setVal(0.0);
//
//            eta_mf[lev]->FillBoundary();
//
//            Set::Vector DX(geom[lev].CellSize());
//
//            for (MFIter mfi(*model_mf[lev], false); mfi.isValid(); ++mfi)
//            {
//                amrex::Box bx = mfi.grownnodaltilebox();
//
//                amrex::Array4<MODEL> const &model = model_mf[lev]->array(mfi);
//                amrex::Array4<const Set::Scalar> const &eta = eta_mf[lev]->array(mfi);
//
//                amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) {
//                    model(i,j,k) = MODEL::Zero();
//                    if(plastic.on) model(i,j,k).SetHardening(plastic.hardening);
//                    for (unsigned int n = 0; n < elastic.models.size(); n++) 
//                        model(i,j,k) += eta(i,j,k,n) * elastic.models[n];
//                });
//            }

            disp_mf[lev]->setVal(0.0);

            //Util::RealFillBoundary(*model_mf[lev],geom[lev]);
        }

        // Degrading the modulus
        for (int ilev = 0; ilev <= finest_level; ++ilev)
        {
            Util::RealFillBoundary(*crack.c_mf[ilev],geom[ilev]);
            Util::RealFillBoundary(*model_mf[ilev],geom[ilev]);

            amrex::Box domain = geom[ilev].Domain();
            domain.convert(amrex::IntVect::TheNodeVector());
            
            for (amrex::MFIter mfi(*disp_mf[ilev],true); mfi.isValid(); ++mfi)
            {
                amrex::Box box = mfi.grownnodaltilebox() & domain;
                amrex::Array4<const Set::Scalar> const& c = (*crack.c_mf[ilev]).array(mfi);
                amrex::Array4<MODEL> model = (model_mf)[ilev]->array(mfi);

                amrex::ParallelFor (box,[=] AMREX_GPU_DEVICE(int i, int j, int k){
                                            Set::Scalar _temp = 0.0;
                                            // _temp = crack.cracktype->g_phi(c(i,j,k,0),0);
                                            _temp = crack.cracktype.g_phi(c(i,j,k,0),0) + crack.scaleModulusMax;
                    
                                            if (std::isnan(_temp)) Util::Abort(INFO);
                                            if(_temp < 0.0) _temp = 0.;
                                            if(_temp > 1.0) _temp = 1.0;
                    
                                            model(i,j,k).DegradeModulus(1.-_temp);
                                        });
            }
            Util::RealFillBoundary(*model_mf[ilev],geom[ilev]);
        }

        elastic.bc->SetTime(a_time);
        elastic.bc->Init(rhs_mf,geom);

        amrex::LPInfo info;
        Operator::Elastic<MODEL::sym> elastic_op(Geom(0,finest_level), grids, DistributionMap(0,finest_level), info);
        elastic_op.SetUniform(false);
        elastic_op.SetBC(elastic.bc);

        Set::Scalar tol_rel = 1E-8, tol_abs = 1E-8;

        IO::ParmParse pp("elastic");
        elastic.solver = new Solver::Nonlocal::Newton<MODEL>(elastic_op);
        pp.queryclass("solver",*elastic.solver);

        elastic.solver->solve(disp_mf,rhs_mf,model_mf,tol_rel,tol_abs);

        for (int lev = 0; lev <= disp_mf.finest_level; lev++)
        {
            amrex::Box domain = geom[lev].Domain();
            domain.convert(amrex::IntVect::TheNodeVector());

            const amrex::Real* DX = geom[lev].CellSize();
            for (MFIter mfi(*disp_mf[lev], false); mfi.isValid(); ++mfi)
            {
                amrex::Box bx = mfi.grownnodaltilebox() & domain;
                amrex::Array4<MODEL>        const &model = model_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>       const &stress  = stress_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>       const &strain  = strain_mf[lev]->array(mfi);
                amrex::Array4<const Set::Scalar> const &disp  = disp_mf[lev]->array(mfi);


                amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) {
                    std::array<Numeric::StencilType,AMREX_SPACEDIM>
                        sten = Numeric::GetStencil(i,j,k,bx);

                    if (model(i,j,k).kinvar == Model::Solid::KinematicVariable::F)
                    {
                        Set::Matrix F = Set::Matrix::Identity() + Numeric::Gradient(disp,i,j,k,DX,sten);
                        Set::Matrix P = model(i,j,k).DW(F);
                        Numeric::MatrixToField(stress,i,j,k,P);
                        Numeric::MatrixToField(strain,i,j,k,F);
                    }
                    else
                    {                    
                        Set::Matrix gradu = Numeric::Gradient(disp,i,j,k,DX,sten);
                        Set::Matrix sigma = model(i,j,k).DW(gradu);
                        Set::Matrix eps = 0.5*(gradu + gradu.transpose());
                        Numeric::MatrixToField(stress,i,j,k,sigma);
                        Numeric::MatrixToField(strain,i,j,k,eps);
                    }
                });
            }
            Util::RealFillBoundary(*stress_mf[lev],geom[lev]);
            Util::RealFillBoundary(*strain_mf[lev],geom[lev]);
        }
    }

    void Advance(int lev, Set::Scalar /*time*/, Set::Scalar dt) override
    {
        if (plastic.on)
        {
            Util::RealFillBoundary(*model_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.strainp_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.gamdotalpha_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.gamalpha_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.strainp_eq_mf[lev],geom[lev]);
            // Util::RealFillBoundary(*stress_mf[lev],geom[lev]);
            // Util::RealFillBoundary(*strain_mf[lev],geom[lev]);

            amrex::Box domain = geom[lev].Domain();
            domain.convert(amrex::IntVect::TheNodeVector());
            
            const Set::Scalar* DX = geom[lev].CellSize();
            Util::Warning(INFO,"Need to determine why tiling isn't working...");

            for ( amrex::MFIter mfi(*eta_mf[lev],false); mfi.isValid(); ++mfi )
            {
                const amrex::Box& bx = mfi.grownnodaltilebox() & domain;
                amrex::Array4<MODEL>                const& model        = model_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>          const& stress       = stress_mf[lev]->array(mfi);
                amrex::Array4<const Set::Scalar>    const& strain       = strain_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>          const& strainp      = plastic.strainp_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>          const& strainp_eq   = plastic.strainp_eq_mf[lev]->array(mfi);
                amrex::Array4<const Set::Scalar>    const& disp         = disp_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>          const& gamdotalpha  = plastic.gamdotalpha_mf[lev]->array(mfi);
                amrex::Array4<Set::Scalar>          const& gamalpha     = plastic.gamalpha_mf[lev]->array(mfi);

                amrex::IndexType type = eta_mf[lev]->ixType();
                amrex::ParallelFor (bx,[=] AMREX_GPU_DEVICE(int i, int j, int k){
                    Set::Matrix sigma = Numeric::FieldToMatrix(stress,i,j,k);
                    Set::Matrix eps = Numeric::FieldToMatrix(strain,i,j,k);
                    Set::Matrix3 eps_grad = Numeric::GradientMatrix(strain,i,j,k,DX);

                    Set::Vector x;
                    // NODE
                    if (type == amrex::IndexType::TheNodeType())
                    {
                        AMREX_D_TERM(x(0) = geom[lev].ProbLo()[0] + ((amrex::Real)(i)) * geom[lev].CellSize()[0];,
                                    x(1) = geom[lev].ProbLo()[1] + ((amrex::Real)(j)) * geom[lev].CellSize()[1];,
                                    x(2) = geom[lev].ProbLo()[2] + ((amrex::Real)(k)) * geom[lev].CellSize()[2];);
                    }
                    else if (type == amrex::IndexType::TheCellType())
                    {
                        AMREX_D_TERM(x(0) = geom[lev].ProbLo()[0] + ((amrex::Real)(i) + 0.5) * geom[lev].CellSize()[0];,
                                    x(1) = geom[lev].ProbLo()[1] + ((amrex::Real)(j) + 0.5) * geom[lev].CellSize()[1];,
                                    x(2) = geom[lev].ProbLo()[2] + ((amrex::Real)(k) + 0.5) * geom[lev].CellSize()[2];);
                    }

                    bool outputflag = false;
                    if ((x - Set::Vector::Zero()).norm() < 1.e-2) outputflag=true;
                    //Util::Message(INFO, "Outputflag = ", outputflag, " x = ", x);

                    std::array<Set::Vector,12> gamdotgrad;
                    std::array<Set::Vector,12> gamgrad;
                    std::array<Numeric::StencilType,AMREX_SPACEDIM> sten = Numeric::GetStencil(i,j,k,bx);

                    for (int n=0; n<12; n++)
                    {
                        gamdotgrad[n] = Numeric::Gradient(gamdotalpha,i,j,k,n,DX,sten);
                        gamgrad[n] = Numeric::Gradient(gamalpha,i,j,k,n,DX,sten);
                    }

                    model(i,j,k).ComputePlasticStrainRate(sigma,gamdotgrad,gamgrad,dt,(outputflag & plastic.debug));

                    if(plastic.do_epsp_evol)
                    {
                        model(i,j,k).Advance(sigma,eps,eps_grad,plastic.epsp_evol_int*dt);

                        Set::Matrix epsp = model(i,j,k).GetPlasticState();
                        if (model(i,j,k).kinvar == Model::Solid::KinematicVariable::F)
                        {
                            Set::Matrix F = Set::Matrix::Identity() + Numeric::Gradient(disp,i,j,k,DX,sten);
                            Set::Matrix P = model(i,j,k).DW(F);
                            Numeric::MatrixToField(stress,i,j,k,P);
                        }
                        else
                        {
                            Set::Matrix gradu = Numeric::Gradient(disp,i,j,k,DX,sten);
                            sigma = model(i,j,k).DW(gradu);
                            Numeric::MatrixToField(stress,i,j,k,sigma);
                        }
                        Numeric::MatrixToField(strainp,i,j,k,epsp);
                        strainp_eq(i,j,k) = epsp.norm();
                        //plastic.do_epsp_evol = false;
                    }
                        
                    for (int n=0; n<12; n++)
                    {
                        gamalpha(i,j,k,n) = model(i,j,k).gamalpha[n];
                        gamdotalpha(i,j,k,n) = model(i,j,k).gamdotalpha[n];
                    }
                });
            }

            Util::RealFillBoundary(*model_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.strainp_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.gamdotalpha_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.gamalpha_mf[lev],geom[lev]);
            Util::RealFillBoundary(*plastic.strainp_eq_mf[lev],geom[lev]);
            Util::RealFillBoundary(*stress_mf[lev],geom[lev]);
            Util::RealFillBoundary(*strain_mf[lev],geom[lev]);
        }
    }
    
    void Integrate(int amrlev, Set::Scalar /*time*/, int /*step*/,
                    const amrex::MFIter &mfi, const amrex::Box &box) override
    {
        const amrex::Real *DX = geom[amrlev].CellSize();
        amrex::Box domain = geom[amrlev].Domain();
        domain.convert(amrex::IntVect::TheNodeVector());


        Set::Scalar dv = AMREX_D_TERM(DX[0], *DX[1], *DX[2]);
        #if AMREX_SPACEDIM == 3
        Set::Vector da(AMREX_D_DECL(DX[1]*DX[2], DX[2]*DX[0], DX[0]*DX[1]));
        #endif

        const Dim3 lo= amrex::lbound(domain)/*, hi = amrex::ubound(domain)*/;
        const Dim3 /*boxlo= amrex::lbound(box),*/ boxhi = amrex::ubound(box);

        amrex::Array4<const amrex::Real> const &stress = (*stress_mf[amrlev]).array(mfi);
        amrex::ParallelFor(box, [=] AMREX_GPU_DEVICE(int i, int j, int k) {

            #if AMREX_SPACEDIM == 3

            if (i == lo.x && (j < boxhi.y && k < boxhi.z))
            {
                trac_lo[0](0) += 0.25 * (stress(i,j,k,0) + stress(i,j+1,k,0) + stress(i,j,k+1,0) + stress(i,j+1,k+1,0)) * da(0);
            } 

            #endif

        });
            
    }

    void TagCellsForRefinement(int lev, amrex::TagBoxArray &a_tags, amrex::Real /*time*/, int /*ngrow*/) override
    {
        Set::Vector DX(geom[lev].CellSize());
        Set::Scalar DXnorm = DX.lpNorm<2>();
        a_tags.setVal(amrex::TagBox::CLEAR);
        for (amrex::MFIter mfi(*eta_mf[lev], TilingIfNotGPU()); mfi.isValid(); ++mfi)
        {
            amrex::Box bx = mfi.tilebox();
            amrex::Array4<char> const &tags = a_tags.array(mfi);
            amrex::Array4<Set::Scalar> const &eta = eta_mf[lev]->array(mfi);
            amrex::Array4<Set::Scalar> const &disp = disp_mf[lev]->array(mfi);
            amrex::Array4<const Set::Scalar> const& strainp_eq = plastic.strainp_eq_mf[lev]->array(mfi);
            amrex::Array4<const Set::Scalar> const& c = crack.c_mf[lev]->array(mfi);
            amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) {
                {
                    Set::Vector grad = Numeric::Gradient(eta, i, j, k, 0, DX.data());
                    if (grad.lpNorm<2>() * DXnorm > 0.01)
                        tags(i, j, k) = amrex::TagBox::SET;
                }
                {
                    Set::Vector grad = Numeric::Gradient(disp, i, j, k, 1, DX.data());
                    if (grad.lpNorm<2>() * DXnorm > m_elastic_ref_threshold)
                        tags(i, j, k) = amrex::TagBox::SET;
                }
                {
                    Set::Vector grad = Numeric::Gradient(strainp_eq, i, j, k, 0, DX.data());
                    if (grad.lpNorm<2>() * DXnorm > m_elastic_ref_threshold)
                        tags(i, j, k) = amrex::TagBox::SET;
                }
                {
                    Set::Vector grad = Numeric::Gradient(c, i, j, k, 0, DX.data());
                    if (grad.lpNorm<2>()*DXnorm >= crack.refinement_threshold)
                        tags(i, j, k) = amrex::TagBox::SET;
                }
            });
        }
    }

    void TimeStepComplete(amrex::Real /*time*/,int /*iter*/)
    {
        if (plastic.do_epsp_evol) plastic.do_epsp_evol = false;
    }

private:
    Set::Field<Set::Scalar> eta_mf;
    Set::Field<Set::Scalar> disp_mf;
    Set::Field<Set::Scalar> rhs_mf;
    Set::Field<Set::Scalar> res_mf;
    Set::Field<Set::Scalar> stress_mf;
    Set::Field<Set::Scalar> strain_mf;

    Set::Vector trac_lo[AMREX_SPACEDIM];
    Set::Vector trac_hi[AMREX_SPACEDIM];


    Set::Field<MODEL> model_mf;

    IC::IC *ic = nullptr;          ///< Pointer to abstract IC object
    BC::BC<Set::Scalar> *mybc;        ///< Stock generic boundary condition object
    
    struct {
        bool do_elastic_solve = true;
        std::vector<MODEL> models;
        Solver::Nonlocal::Newton<MODEL> *solver;//(elastic.op);
        BC::Operator::Elastic::Elastic *bc;
        int interval=1;
    } elastic;

    struct{
        bool on = false;
        bool hardening = false;
        Set::Field<Set::Scalar> gamalpha_mf;
        Set::Field<Set::Scalar> gamdotalpha_mf;
        Set::Field<Set::Scalar> strainp_mf;
        Set::Field<Set::Scalar> strainp_eq_mf;
        bool debug = false;
        bool do_epsp_evol = false;
        int epsp_evol_int = 1;
    } plastic;

    struct{
        Set::Field<Set::Scalar> c_mf;                ///< crack field at current time step
        Model::Interface::Crack::Constant cracktype;                      ///< type of crack. See Crack/Constant or Crack/Sin
        amrex::Vector<std::string> ic_type;                            ///< crack IC type. See IC/Notch and IC/Ellipsoid
        amrex::Vector<IC::IC*> ic;                                     ///< crack IC. See IC/Notch and IC/Ellipsoid
        bool is_ic = false;

        Set::Scalar scaleModulusMax = 0.02;         ///< material modulus ratio inside crack (default = 0.02).
        Set::Scalar refinement_threshold = 0.001;
    } crack;

    Set::Scalar m_elastic_ref_threshold = 0.01;

};
} // namespace Integrator
#endif
