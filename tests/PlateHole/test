#!/usr/bin/env python3
import numpy, yt, pylab, os, pandas, sys, math, glob
from numpy import arctan2, sqrt, sin, cos, linspace, meshgrid, inf, pi


##
## EXACT SOLUTION
##
a = 0.5
sig0 = 0.1
#0.000685
#def sigma_rr(r,t): return sig0*(1 - 4*(a/r)**2 + 3*(a/r)**4)*cos(2*t)
#def sigma_tt(r,t): return - sig0*(1 + 3*(a/r)**4)*cos(2*t)
#def sigma_rt(r,t): return sig0*(-1 - 2*(a/r)**2 + 3*(a/r)**4)*sin(2*t)
def sigma_rr(r,t):
    return 0.5*sig0*(1 - (a/r)**2) + 0.5*sig0*(1 - 4*(a/r)**2 + 3*(a/r)**4)*cos(2*t)
def sigma_tt(r,t):
    return 0.5*sig0*(1 + (a/r)**2) - 0.5*sig0*(1 + 3*(a/r)**4)*cos(2*t)
def sigma_rt(r,t):
    return -0.5*sig0*(1 + 2*(a/r)**2 - 3*(a/r)**4)*sin(2*t)
def sigma_YY(x,y):
    r = sqrt(x**2 + y**2)
    t = arctan2(y,x)
    return sigma_rr(r,t)*sin(t)**2 + 2*sigma_rt(r,t)*cos(t)*sin(t) + sigma_tt(r,t)*cos(t)**2
def sigma_XX(x,y):
    r = sqrt(x**2 + y**2)
    t = arctan2(y,x)
    return (sigma_rr(r,t)*cos(t)**2 - 2*sigma_rt(r,t)*cos(t)*sin(t) + sigma_tt(r,t)*sin(t)**2)
def sigma_XY(x,y):
    r = sqrt(x**2 + y**2)
    t = arctan2(y,x)
    return - ((sigma_rr(r,t)-sigma_tt(r,t))*sin(t)*cos(t) + (cos(t)**2-sin(t)**2)*sigma_rt(r,t) )


xmin = -16
xmax = 16
ymin = 0.0
ymax = 0.0

##
## READ IN NUMERICAL SOLUTION
##


outdir = sys.argv[1]

generate_ref_data = False  # Change to True if you need to generate new reference data
tolerance = 1E-8

path = sorted(glob.glob("{}/*cell/".format(outdir)))[-1]
ds = yt.load(path)
dim = int(ds.domain_dimensions[0] > 1) + int(ds.domain_dimensions[1] > 1) + int(ds.domain_dimensions[2] > 1)

def integrate(x,y):
    ret = 0
    for i in range(len(x)-1): ret = ret + 0.5*(y[i+1]+y[i]) * (x[i+1]-x[i])
    return ret

if dim != 2: raise(Exception("Not implemented for 3D yet"))

prof = ds.ray([xmin,ymin,0],[xmax,ymax,0],)
df = prof.to_dataframe([("gas","x"),("gas","y"),"stress_xx","stress_xy","stress_yy"])

class ref:
    x = numpy.linspace(xmin,xmax,1000)
    y = numpy.linspace(ymin,ymax,1000)
class new:
    ret = [numpy.array(_x) for _x in zip(*sorted(zip(
        df["x"],df["y"],df["stress_xx"],df["stress_xy"],df["stress_yy"])))]
    x = ret[0]
    y = ret[1]
    sigxx = ret[2]
    sigxy = ret[3]
    sigyy = ret[4]

pylab.clf()
pylab.plot(new.x,new.sigxx,marker='o',color='C0',label="xx",linestyle="",markerfacecolor='None')
pylab.plot(ref.x,sigma_XX(ref.x,ref.y),color='C0')
#pylab.plot(new.x,new.sigxy,marker='o',color='C1',label="xy",linestyle="")
#pylab.plot(new.x,sigma_XY(new.y,new.x),color='C1')
pylab.plot(new.x,new.sigyy,marker='o',color='C2',label="yy",linestyle="",markerfacecolor='None')
pylab.plot(ref.x,sigma_YY(ref.x,ref.y),color='C2')
pylab.ylim(min(new.sigyy), max(new.sigyy))
#pylab.plot(new.x,new.sigxy)
#pylab.plot(new.x,new.sigyy)
pylab.legend()
pylab.tight_layout()
#pylab.show()

#pylab.clf()
#pylab.plot(ref.x,ref.eta,color='C0',label='reference')
#pylab.plot(new.x,new.eta,color='C1',label='new',linestyle='--')
pylab.savefig("{}/etas.png".format(outdir))
#
#pylab.clf()
#pylab.plot(ref.x,ref.u,color='C0',label='reference')
#pylab.plot(new.x,new.u,color='C1',label='new',linestyle='--')
#pylab.savefig("{}/u.png".format(outdir))
#
#pylab.clf()
#pylab.plot(ref.x,ref.sig,color='C0',label='reference')
#pylab.plot(new.x,new.sig,color='C1',label='new',linestyle='--')
#pylab.savefig("{}/sig.png".format(outdir))
#
#err = numpy.sqrt(integrate(ref.x, (numpy.interp(ref.x, new.x, new.eta) - ref.eta)**2))
#print("eta error",err)
#if err > tolerance: raise(Exception("Error in eta"))
#if math.isnan(err): raise(Exception("eta is nan"))
#
#err = numpy.sqrt(integrate(ref.x, (numpy.interp(ref.x, new.x, new.u) - ref.u)**2))
#print("u error",err)
#if err > tolerance: raise(Exception("Error in displacement"))
#if math.isnan(err): raise(Exception("displacement is nan"))
#
#err = numpy.sqrt(integrate(ref.x, (numpy.interp(ref.x, new.x, new.sig) - ref.sig)**2))
#print("sig error",err)
#if err > tolerance: raise(Exception("Error in sigma"))
#if math.isnan(err): raise(Exception("sigma is nan"))

exit(0)









